{"searchDocs":[{"title":"ACT (Access Control Trie)","type":0,"sectionRef":"#","url":"/docs/act/","content":"ACT (Access Control Trie) Show example of creating grantee listShow example of secure uploadShow example of secure download","keywords":"","version":"Next"},{"title":"Chequebook and Cheques","type":0,"sectionRef":"#","url":"/docs/chequebook/","content":"Chequebook and Cheques Get chequebook balanceWithdraw from chequebook to node walletDeposit to chequebook from node walletGet chequesCashout cheque","keywords":"","version":"Next"},{"title":"Bee JS - The Swarm JS Library","type":0,"sectionRef":"#","url":"/docs/","content":"","keywords":"","version":"Next"},{"title":"Development‚Äã","type":1,"pageTitle":"Bee JS - The Swarm JS Library","url":"/docs/#development","content":" We'd love you to join us! Are you up to the challenge of helping us to create bee-js and the other incredible technologies we're building? Have a look at our Github - Ethersphere.  ","version":"Next","tagName":"h2"},{"title":"Community‚Äã","type":1,"pageTitle":"Bee JS - The Swarm JS Library","url":"/docs/#community","content":" There is a vibrant and buzzing community behind Swarm, get involved in one of our group channels.  Official Swarm website.Discord room.Twitter @ethswarm.Reddit channel.  ","version":"Next","tagName":"h2"},{"title":"Reporting a bug‚Äã","type":1,"pageTitle":"Bee JS - The Swarm JS Library","url":"/docs/#reporting-a-bug","content":" If anything isn't working, get in touch and let us know! Every Bee is important to us and we'll get right to work on fixing it for you as soon as possible. üêù  ","version":"Next","tagName":"h2"},{"title":"Examples‚Äã","type":1,"pageTitle":"Bee JS - The Swarm JS Library","url":"/docs/#examples","content":" We have repo with some examples that might be interesting for you to see. Check it out here. ","version":"Next","tagName":"h2"},{"title":"GSOC","type":0,"sectionRef":"#","url":"/docs/gsoc/","content":"GSOC Show mining the writer private key for the targeted overlay address GistShow a simple listener, and a simple send invocation Gist1 Gist2Show Identifier class usage Gist","keywords":"","version":"Next"},{"title":"Community","type":0,"sectionRef":"#","url":"/docs/community/","content":"Community try-out-swarm - a quick bootstrap for Swarm including shell scripts for Bee and typescript scripts using bee-js","keywords":"","version":"Next"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/getting-started/","content":"Getting Started First you need to get bee-js into your project. This can be done using your favourite package management tool or directly: npmyarnscript tag npm install @ethersphere/bee-js --save After that you need to import the Bee class and create a bee instance connecting to your Bee node (here we assume it runs on localhost on default port). Be aware, if you will pass invalid URL the constructor will throw an exception! import { Bee } from &quot;@ethersphere/bee-js&quot; const bee = new Bee('http://localhost:1633') That‚Äôs it! now you can use the bee object. Run your own Bee node You can find out more about running Bee node in the Bee docs Using &lt;script&gt; import If you include bee-js using the unpkg.com script link then all the exported components will be available to you under global namespace BeeJs: &lt;script src=&quot;https://unpkg.com/@ethersphere/bee-js/dist/index.browser.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const bee = new BeeJs.Bee('...') &lt;/script&gt; ","keywords":"","version":"Next"},{"title":"Manifests","type":0,"sectionRef":"#","url":"/docs/manifests/","content":"Manifests Intro on what Manifests (a.k.a Mantaray nodes) areShow an example of loading manifests GistShow an example of working with loaded manifestsShow creating a manifest from zero, working with it, saving","keywords":"","version":"Next"},{"title":"Pinning","type":0,"sectionRef":"#","url":"/docs/pinning/","content":"Pinning","keywords":"","version":"Next"},{"title":"Crypto Primitives","type":0,"sectionRef":"#","url":"/docs/primitives/","content":"Crypto Primitives Show PrivateKey, PublicKey, EthAddress, Signature interoperability GistShow BZZ, DAI utilities, conversion GistShow Reference and CID interoperability GistShow Bytes keccak256 utility Gist","keywords":"","version":"Next"},{"title":"Staking","type":0,"sectionRef":"#","url":"/docs/staking/","content":"Staking Get staked xBZZStake xBZZGet redistribution state","keywords":"","version":"Next"},{"title":"Checking Node Status","type":0,"sectionRef":"#","url":"/docs/status/","content":"Checking Node Status Get health and readinessGet topologyGet addressesGet node version and API versionGet node infoGet chain stateGet reserve state","keywords":"","version":"Next"},{"title":"Buying Storage","type":0,"sectionRef":"#","url":"/docs/storage/","content":"Buying Storage A complete section dedicated to working with stampsgetStorageCost function to calculate BZZ based on gigabytes and Duration GistbuyStorage function to provide gigabytes and Duration GistgetSizeExtensionCost and extendStorageSize which was previously dilutegetDurationExtensionCost and extendStorageDuration which was previously topupgetAllPostageBatch to list and review stamps","keywords":"","version":"Next"},{"title":"Postal Service over Swarm","type":0,"sectionRef":"#","url":"/docs/pss/","content":"","keywords":"","version":"Next"},{"title":"Getting the relevant data‚Äã","type":1,"pageTitle":"Postal Service over Swarm","url":"/docs/pss/#getting-the-relevant-data","content":" When you start bee, you may find all the necessary information in the log:  INFO using existing swarm network address: 9e2ebf266369090091620db013aab164afb1574aedb3fcc08ce8dc6e6f28ef54 INFO swarm public key 03e0cee7e979fa99350fc2e2f8c81d857b525b710380f238742af269bb794dfd3c INFO pss public key 02fa24cac43531176d21678900b37bd800c93da3b02c5e11572fb6a96ec49527fa INFO using ethereum address 5f5505033e3b985b88e20616d95201596b463c9a   Let's break it down:  Ethereum address is the public address of your node wallet. Together with the corresponding private key, it is used for things such as making Ethereum transactions (receiving and sending ETH and BZZ); receiving, claiming and singing cheques and the Swarm network address is also derived from it.The Swarm network address defines your location in the kademlia and within the context of PSS is used for addressing the trojan chunks to you. In other words, others may use it to send you a message.PSS public key can be used by others to encrypt their messages for you.  ","version":"Next","tagName":"h2"},{"title":"Sending message‚Äã","type":1,"pageTitle":"Postal Service over Swarm","url":"/docs/pss/#sending-message","content":" To send data simply define a topic, prefix of the recipient's swarm network address (we recommend 4-6 character prefix length) and the data to be send.  Your communication privacy may be at risk When sending PSS messages without encryption key, any Bee node through which the trojan chunk passes would be able to read the message.  TypeScriptJavaScript /** * @param {string} topic * @param {string} targetPrefix * @param {string|Uint8Array} data * @param {string} encryptionKey */ bee.pssSend('topic', '9e2e', 'Hello!')   If you want to encrypt the message, you may provide the recipient's PSS public key.  TypeScriptJavaScript bee.pssSend( 'topic', '9e2e', 'Encrypted Hello!', '02fa24cac43531176d21678900b37bd800c93da3b02c5e11572fb6a96ec49527fa', )   ","version":"Next","tagName":"h2"},{"title":"Retrieving message‚Äã","type":1,"pageTitle":"Postal Service over Swarm","url":"/docs/pss/#retrieving-message","content":" As a recipient, you have two ways how to receive the message. If you are expecting one off message (which is the intended PSS use case to exchange credentials for further direct communication), you can use the pssReceive method.  TypeScriptJavaScript const message = await bee.pssReceive('topic') console.log(message.text()) // prints the received message   If you want to subscribe to multiple messagees, use the pssSubscribe method.  TypeScriptJavaScript const handler = { onMessage: (message: Data) =&gt; {console.log(message.text())}, onError: (error: BeeError) =&gt; {console.log(error)} } // Subscribe const subscription = bee.pssSubscribe('topic', handler) // Terminate the subscription subscription.cancel()  ","version":"Next","tagName":"h2"},{"title":"SOC and Feeds","type":0,"sectionRef":"#","url":"/docs/soc-and-feeds/","content":"","keywords":"","version":"Next"},{"title":"Single Owner Chunks‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#single-owner-chunks","content":" Bee-js calculates a SOC address as the hash of an identifier and owner. The identifier is a 32 bytes long arbitrary data, usually expected as a hex string or a Uint8Array. The owner is an Ethereum address that consists of 20 bytes in a format of a hex string or Uint8Array.  SOCs are immutable! You might be tempted to modify a SOC's content to &quot;update&quot; the chunk. Reuploading of SOC is forbidden in Swarm as it might create uncertain behavior. Bee node will reject the API call if it finds already existing SOC for the given address. Either use a different identifier, or you might be looking for Feeds as your use case.  ","version":"Next","tagName":"h2"},{"title":"Reading SOCs‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#reading-socs","content":" To read data from a SOC, we need to make a reader object bound to a specific owner. Then we can download the data with the provided chunk's identifier.  const owner = '0x8d3766440f0d7b949a5e32995d09619a7f86e632' const socReader = bee.makeSOCReader(owner) const identifier = '0000000000000000000000000000000000000000000000000000000000000000' const soc = await socReader.download(identifier) const data = soc.payload()   ","version":"Next","tagName":"h3"},{"title":"Writing SOCs‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#writing-socs","content":" When writing a SOC, first, we need to make a writer object. Because we need to sign the chunk, we need to pass in a signer object. The signer object can be either an Ethereum private key (as a hex string or Uint8Array) or an instance of the Signer interface. The Signer interface can be used for integration with 3rd party Ethereum wallet applications because Swarm uses the same format for signing chunks that Ethereum uses for signing transactions.  Default signer When you are instantiating Bee class you can pass it a default signer that will be used if you won't specify it directly for the makeSOCWriter. See Bee constructor for more info.  Ethereum Wallet signers If you want to use your browser Ethereum Wallet like Metamask you can use utility called makeEthereumWalletSigner that we ship with bee-js which creates a Signer object out of given EIP-1193 compatible provider. See it used in our example here. import { Utils } from '@ethersphere/bee-js' const signer = Utils.makeEthereumWalletSigner(window.ethereum) ...   type SyncSigner = (digest: Data) =&gt; Signature | string type AsyncSigner = (digest: Data) =&gt; Promise&lt;Signature | string&gt; /** * Interface for implementing Ethereum compatible signing. * * @property sign The sign function that can be sync or async * @property address The Ethereum address of the signer */ export type Signer = { sign: SyncSigner | AsyncSigner address: EthAddress }   Your communication privacy may be at risk We suggest using either ephemeral private keys (e.g. randomly generated) or the Signer interface when writing to SOC or Feeds. Never use your real Ethereum private keys here (or in any web applications really) directly because you may lose your funds stored on it.  Using the writer interface is similar to using the reader:  const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) const signer = '0x634fb5a872396d9693e5c9f9d7233cfa93f395c093371017ff44aa9ae6564cdd' const socWriter = bee.makeSOCWriter(signer) const identifier = '0000000000000000000000000000000000000000000000000000000000000000' const data = new Uint8Array([1, 2, 3]) const response = await socWriter.upload(postageBatchId, identifier, data)   ","version":"Next","tagName":"h3"},{"title":"Feeds‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#feeds","content":" Feeds are an abstraction built on top of SOCs to provide mutable resources on the otherwise immutable data types that Swarm supports.  One of the most common use cases for feeds is to store mutable data in an immutable address. For example, when hosting a website on Swarm, we may want its address stored in ENS, but we don't want to pay for changing the reference every time the site is updated.  A feed is defined by its owner (see above), a topic (32 bytes arbitrary data as a hex string or Uint8Array), and a type. type defines how the updates and lookup of the feed index are made (currently only the sequence type is supported).  The publisher is the owner of the feed, and only they can post updates to the feed. Posting an update requires (1) constructing the identifier from the topic and the correct index and (2) signing it concatenated together with the hash of the arbitrary content of the update.  Conversely, users can consume a feed by retrieving the chunk by its address. Retrieving an update requires the consumer to construct the address from the owner‚Äôs address and the identifier. To calculate the identifier, they need the topic and the appropriate index. For this, they need to know the indexing scheme.  Feeds enable Swarm users to represent a sequence of content updates. The content of the update is the payload that the feed owner signs against the identifier. The payload can be a swarm reference from which the user can retrieve the associated data.  ","version":"Next","tagName":"h2"},{"title":"Topic‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#topic","content":" In Swarm, topic is a 32-byte long arbitrary byte array. It's possible to choose an arbitrary topic for each application, and then knowing someone's (or something's) address, it's possible to find their feeds. Also, this can be the hash of a human-readable string, specifying the topic and optionally the subtopic of the feed. There is a helper function provided for that:  const topic = bee.makeFeedTopic('my-dapp.eth/outbox')   ","version":"Next","tagName":"h3"},{"title":"High level JSON API‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#high-level-json-api","content":" Many applications are storing or manipulating data in JSON. bee-js has convenience high level API to use feeds with JSON objects. It consists of two methods:  setJsonFeed method to set JSON compatible data to feedgetJsonFeed method to get JSON compatible data (and parse them) from feed  Bee's instance signer You can pass a Signer (or compatible data) into Bee class constructor, which then will be used as default Signer.  const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) await bee.setJsonFeed( postageBatchId, 'some cool arbitraty topic', { some: ['cool', { json: 'compatible' }, 'object']}, { signer: '0x634fb5a872396d9693e5c9f9d7233cfa93f395c093371017ff44aa9ae6564cdd' } ) const data = await bee.getJsonFeed( 'some cool arbitraty topic', { signer: '0x634fb5a872396d9693e5c9f9d7233cfa93f395c093371017ff44aa9ae6564cdd' } ) console.log(data) // Prints: { some: ['cool', { json: 'compatible' }, 'object']}   ","version":"Next","tagName":"h3"},{"title":"Low level API‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#low-level-api","content":" Low level API is an API that is more flexible in its usage, but requires better understanding and mainly more method calls.  Reading feeds‚Äã  To read data from a feed, we need to make a reader object for a specific type, topic and owner, then we can download the latest update containing a reference.  const topic = '0000000000000000000000000000000000000000000000000000000000000000' const owner = '0x8d3766440f0d7b949a5e32995d09619a7f86e632' const feedReader = bee.makeFeedReader('sequence', topic, owner) const feedUpdate = await feedReader.download() console.log(feedUpdate.reference) // prints the latest reference stored in the feed   Writing feeds‚Äã  When writing a feed, typically an immutable content is uploaded first, and then its reference is updated in the feed. The signer here is the same as with writing the SOCs (with the same caveats!).  const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) const data = new Uint8Array([1, 2, 3]) const reference = await bee.uploadData(data) const topic = '0000000000000000000000000000000000000000000000000000000000000000' const signer = '0x634fb5a872396d9693e5c9f9d7233cfa93f395c093371017ff44aa9ae6564cdd' const feedWriter = bee.makeFeedWriter('sequence', topic, signer) const response = await feedWriter.upload(postageBatchId, reference)   ","version":"Next","tagName":"h3"},{"title":"Using feed manifest‚Äã","type":1,"pageTitle":"SOC and Feeds","url":"/docs/soc-and-feeds/#using-feed-manifest","content":" One of the most common use cases for feeds is to store mutable data in an immutable address. For example, when hosting a website on Swarm, we may want its address stored in ENS, but we don't want to pay for changing the reference every time the site is updated.  Swarm provides a feature called &quot;feed manifests&quot; for this use case. It is a content-addressed chunk that stores a feed's definition (the type, the topic, and the owner). When it is looked up using the bzz endpoint, Swarm recognizes that it refers to a feed and continues the lookup according to the feed parameters.  const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) const topic = '0000000000000000000000000000000000000000000000000000000000000000' const owner = '0x8d3766440f0d7b949a5e32995d09619a7f86e632' const reference = bee.createFeedManifest(postageBatchId, 'sequence', topic, owner)   This creates the feed manifest chunk on Swarm. You can use the returned reference to look up with the /bzz endpoint or use it with ENS. ","version":"Next","tagName":"h3"},{"title":"Upload and Download","type":0,"sectionRef":"#","url":"/docs/upload-download/","content":"","keywords":"","version":"Next"},{"title":"Upload and Download‚Äã","type":1,"pageTitle":"Upload and Download","url":"/docs/upload-download/#upload-and-download","content":" Uploading your data to Swarm is easy with bee-js. Based on your needs you can either upload directly unstructured data, single file or even complex directories. Let's walk through the options one by one.  Postage stamps Uploading to Swarm network require to have Postage stamps for every write operation. To understand better what does it mean see Bee docs - Keep your data alive.  ","version":"Next","tagName":"h2"},{"title":"Data‚Äã","type":1,"pageTitle":"Upload and Download","url":"/docs/upload-download/#data","content":" You can upload and retrieve any string or Uint8Array data with uploadData and downloadData functions.  When you download data the return type is Data interface which extends Uint8Array with convenience functions like:  text() that converts the bytes into UTF-8 encoded stringhex() that converts the bytes into non-prefixed hex stringjson() that converts the bytes into JSON object  const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) const result = await bee.uploadData(postageBatchId, &quot;Bee is awesome!&quot;) // prints Swarm hash of the file with which it can be retrieved // here it is fd79d5e0ebd8407e422f53ce1d7c4c41ebf403be55143900f8d1490560294780 console.log(result.reference) const retrievedData = await bee.downloadData(result.reference) console.log(retrievedData.text()) // prints 'Bee is awesome!'   Tip Swarm reference or hash is a 64 characters long hex string which is the address of the uploaded data, file or directory.  ","version":"Next","tagName":"h3"},{"title":"Single file‚Äã","type":1,"pageTitle":"Upload and Download","url":"/docs/upload-download/#single-file","content":" You can also upload files and include a filename. When you download the file, bee-js will return additional information like contentType or name of the file.  const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) const result = await bee.uploadFile(postageBatchId, &quot;Bee is awesome!&quot;, &quot;textfile.txt&quot;) const retrievedFile = await bee.downloadFile(result.reference) console.log(retrievedFile.name) // prints 'textfile.txt' console.log(retrievedFile.contentType) // prints 'application/octet-stream' console.log(retrievedFile.data.text()) // prints 'Bee is awesome!'   In browsers, you can upload directly File type. The filename is taken from the file object itself, but can be overwritten through the second argument of the uploadFile function.  const file = new File([&quot;foo&quot;], &quot;foo.txt&quot;, { type: &quot;text/plain&quot; }) const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) const result = await bee.uploadFile(postageBatchId, file) const retrievedFile = await bee.downloadFile(result.reference) console.log(retrievedFile.name) // prints 'foo.txt' console.log(retrievedFile.contentType) // prints 'text/plain' console.log(retrievedFile.data.text()) // prints 'foo'   ","version":"Next","tagName":"h3"},{"title":"Files and Directories‚Äã","type":1,"pageTitle":"Upload and Download","url":"/docs/upload-download/#files-and-directories","content":" The last supported mode is upload of files and directories. In browsers, you can easily upload an array of File comming from your form directly as well as FileList. If the files uploaded through uploadFiles have a relative path, they are added relative to this filepath. Otherwise, the whole structure is flattened into single directory.  const foo = new File([&quot;foo&quot;], &quot;foo.txt&quot;, { type: &quot;text/plain&quot; }) const bar = new File([&quot;bar&quot;], &quot;bar.txt&quot;, { type: &quot;text/plain&quot; }) const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) const result = await bee.uploadFiles(postageBatchId, [ foo, bar ]) // upload const rFoo = await bee.downloadFile(result.reference, './foo.txt') // download foo const rBar = await bee.downloadFile(result.reference, './bar.txt') // download bar console.log(rFoo.data.text()) // prints 'foo' console.log(rBar.data.text()) // prints 'bar'   In nodejs, you may utilise the uploadFilesFromDirectory function, which takes directory path as input and upload all files in that directory. Lets assum we have following data structure:  . +-- foo.txt +-- dir | +-- bar.txt   const postageBatchId = await bee.createPostageBatch(&quot;100&quot;, 17) const result = await bee.uploadFilesFromDirectory(postageBatchId, './') // upload recursively current folder const rFoo = await bee.downloadFile(result.reference, './foo.txt') // download foo const rBar = await bee.downloadFile(result.reference, './dir/bar.txt') // download bar console.log(rFoo.data.text()) // prints 'foo' console.log(rBar.data.text()) // prints 'bar'   ","version":"Next","tagName":"h3"},{"title":"Retrieve file from node or gateway‚Äã","type":1,"pageTitle":"Upload and Download","url":"/docs/upload-download/#retrieve-file-from-node-or-gateway","content":" You can always retrieve your files and data directly from the bee node through browser as well. For example, if you want to retrieve the &quot;Bee is awesome!&quot; text uploaded to Swarm in section upload data, you can directly access it with: http://localhost:1633/files/fd79d5...294780  To share files with someone who isn't running a Bee node yet, simply change the host in the link to be one of our public gateways. Send the link to your friends, and they will be able to download the file too!  https://gateway.ethswarm.org/files/fd79d5...294780 ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}